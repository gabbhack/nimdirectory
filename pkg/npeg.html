<!DOCTYPE html>
<html lang="en">
<head>
  <title>Nim Package Directory</title>
  <link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
  <meta charset="utf-8">
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="alternate" type="application/rss+xml" title="New and updated Nim packages" href="https://nimble.directory/packages.xml">
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/highlite.css">
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
  <script type="text/javascript" src="/js/app.js"></script>
</head>
<body>
<nav class="navbar navbar-expand-lg fixed-top py-3">
  <div class="container">
    <a href="/" class="logo fw-500 display-1 text-black text-decoration-none navbar-brand"></a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse">
      <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
        <li class="nav-item mx-2">
          <a href="https://nim-lang.org/" class="nav-link">What's Nim?</a>
        </li>
        <li class="nav-item mx-2">
          <a href="/about.html" class="nav-link">What's Nimble?</a>
        </li>
        <li class="nav-item mx-2">
          <a href="https://github.com/nim-lang/packages/" class="nav-link">Publish your package</a>
        </li>
        <!-- TODO: replace with something different -->
        <li class="nav-item ms-3">
          <a class="nav-link" href="https://www.youtube.com/channel/UCDAYn_VFt0VisL5-1a5Dk7Q/">
            <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="css-i6dzq1"><path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon></svg>
          </a>
        </li>
        <li class="nav-item ms-3">
          <a class="nav-link theme-switcher-btn" id="darkmode" onclick="toggle_dark_mode()" href="#">
            <span id="light-mode-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="css-i6dzq1"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </span>
            <span id="dark-mode-icon">
            <svg viewBox="0 0 24 24" width="18" height="18" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="css-i6dzq1"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
            </span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="content">
  <div class="container">
    <div class="container pt-10">
        <h3 class="mb-3 fw-bold display-6 pt-4">npeg</h3>
        <p class="tags">
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">PEG</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">parser</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">parsing</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">regexp</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">regular</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">grammar</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">lexer</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">lexing</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">pattern</button></a>
                </span>
            
                <span class="tag">
                    <button class="btn-tag pkg-btn-tag">matching</button></a>
                </span>
            
        </p>
        <p class="pkg-desc">some("PEG (Parsing Expression Grammars) string matching library for Nim")</p>
        <a title="Copy" onclick="document.querySelector('#cmd').select();document.execCommand('copy');"
            alt="Copy on clipboard">
            <i class="fa fa-copy"></i>
        </a>
        <input id="cmd" onclick="this.select();" value="nimble install npeg" readonly="">
        <br>
        <small style="font-size: 0.8rem;">Need help? Read <a
                href="https://github.com/nim-lang/nimble#creating-packages">Nimble</a></small>
    </div>

    <div class="container row pt-4" id="pkg-content">
        <div class="col-8 box rounded p-3" id="readme-section">
            
                <document><p><a href="https://opensource.org/licenses/MIT">  <img src="https://img.shields.io/badge/License-MIT-blue.svg" style="max-width: 100%;" alt="License: MIT" /></a>
<img src="https://img.shields.io/badge/stability-stable-green.svg" style="max-width: 100%;" alt="Stability: experimental" /></p>
<img src="https://raw.githubusercontent.com/zevv/npeg/master/doc/npeg.png" align="left" style="max-width: 100%;" alt="NPeg logo" />
<blockquote>
<p>&quot;<em>Because friends don&apos;t let friends write parsers by hand</em>&quot;</p>
</blockquote>
<p>NPeg is a pure Nim pattern matching library. It provides macros to compile
patterns and grammars (PEGs) to Nim procedures which will parse a string and
collect selected parts of the input. PEGs are not unlike regular expressions,
but offer more power and flexibility, and have less ambiguities. (More about
PEGs on <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">Wikipedia</a>)</p>
<p>  <img src="/doc/syntax-diagram.png" style="max-width: 100%;" alt="Graph" /></p>
<p>Some use cases where NPeg is useful are configuration or data file parsers,
robust protocol implementations, input validation, lexing of programming
languages or domain specific languages.</p>
<p>Some NPeg highlights:</p>
<ul>
<li>
<p>Grammar definitions and Nim code can be freely mixed. Nim code is embedded
using the normal Nim code block syntax, and does not disrupt the grammar
definition.</p>
</li>
<li>
<p>NPeg-generated parsers can be used both at run and at compile time.</p>
</li>
<li>
<p>NPeg offers various methods for tracing, optimizing and debugging
your parsers.</p>
</li>
<li>
<p>NPeg can parse sequences of any data types, also making it suitable as a
stage-two parser for lexed tokens.</p>
</li>
<li>
<p>NPeg can draw <a href="/doc/example-railroad.png">cool diagrams</a></p>
</li>
</ul>
<h2>Contents</h2>
<!--  AutoContentStart  -->
<ul>
<li>  <a href="#quickstart">Quickstart</a></li>
<li><a href="#usage">Usage</a>
<ul>
<li>  <a href="#simple-patterns">Simple patterns</a></li>
<li>  <a href="#grammars">Grammars</a></li>
</ul>
</li>
<li><a href="#syntax">Syntax</a>
<ul>
<li>  <a href="#atoms">Atoms</a></li>
<li>  <a href="#operators">Operators</a></li>
</ul>
</li>
<li>  <a href="#precedence-operators">Precedence operators</a></li>
<li><a href="#captures">Captures</a>
<ul>
<li>  <a href="#string-captures">String captures</a></li>
<li><a href="#code-block-captures">Code block captures</a>
<ul>
<li>  <a href="#custom-match-validations">Custom match validations</a></li>
<li>  <a href="#passing-state">Passing state</a></li>
</ul>
</li>
<li>  <a href="#backreferences">Backreferences</a></li>
</ul>
</li>
<li><a href="#more-about-grammars">More about grammars</a>
<ul>
<li>  <a href="#ordering-of-rules-in-a-grammar">Ordering of rules in a grammar</a></li>
<li>  <a href="#templates-or-parameterized-rules">Templates, or parameterized rules</a></li>
<li>  <a href="#composing-grammars-with-libraries">Composing grammars with libraries</a></li>
<li>  <a href="#library-rule-overridingshadowing">Library rule overriding/shadowing</a></li>
</ul>
</li>
<li><a href="#error-handling">Error handling</a>
<ul>
<li>  <a href="#matchresult">MatchResult</a></li>
<li>  <a href="#npegparseerror-exceptions">NpegParseError exceptions</a></li>
<li>  <a href="#other-exceptions">Other exceptions</a></li>
<li>  <a href="#parser-stack-trace">Parser stack trace</a></li>
</ul>
</li>
<li><a href="#advanced-topics">Advanced topics</a>
<ul>
<li>  <a href="#parsing-other-types-then-strings">Parsing other types then strings</a></li>
</ul>
</li>
<li><a href="#some-notes-on-using-pegs">Some notes on using PEGs</a>
<ul>
<li>  <a href="#anchoring-and-searching">Anchoring and searching</a></li>
<li>  <a href="#complexity-and-performance">Complexity and performance</a></li>
<li>  <a href="#end-of-string">End of string</a></li>
<li>  <a href="#non-consuming-atoms-and-captures">Non-consuming atoms and captures</a></li>
<li>  <a href="#left-recursion">Left recursion</a></li>
<li>  <a href="#utf-8--unicode">UTF-8 / Unicode</a></li>
</ul>
</li>
<li><a href="#tracing-and-debugging">Tracing and debugging</a>
<ul>
<li>  <a href="#syntax-diagrams">Syntax diagrams</a></li>
<li>  <a href="#grammar-graphs">Grammar graphs</a></li>
<li>  <a href="#tracing">Tracing</a></li>
</ul>
</li>
<li>  <a href="#compile-time-configuration">Compile-time configuration</a></li>
<li>  <a href="#tracing-and-debugging-1">Tracing and debugging</a></li>
<li><a href="#random-stuff-and-frequently-asked-questions">Random stuff and frequently asked questions</a>
<ul>
<li>  <a href="#why-does-npeg-not-support-regular-peg-syntax">Why does NPeg not support regular PEG syntax?</a></li>
<li>  <a href="#can-npeg-be-used-to-parse-ebnf-grammars">Can NPeg be used to parse EBNF grammars?</a></li>
<li>  <a href="#npeg-and-generic-functions">NPeg and generic functions</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a>
<ul>
<li>  <a href="#parsing-arithmetic-expressions">Parsing arithmetic expressions</a></li>
<li>  <a href="#a-complete-json-parser">A complete JSON parser</a></li>
<li>  <a href="#captures-1">Captures</a></li>
<li>  <a href="#more-examples">More examples</a></li>
</ul>
</li>
<li>  <a href="#future-directions--todos--roadmap--the-long-run">Future directions / Todos / Roadmap / The long run</a></li>
</ul>
<!--  AutoContentEnd  -->
<h2>Quickstart</h2>
<p>Here is a simple example showing the power of NPeg: The macro <code>peg</code> compiles a
grammar definition into a <code>parser</code> object, which is used to match a string and
place the key-value pairs into the Nim table <code>words</code>:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">import</span> <span class="ide">npeg</span>, <span class="ide">strutils</span>, <span class="ide">tables</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">type</span> <span class="ide">Dict</span> <span class="op">=</span> <span class="ide">Table</span>[<span class="ide">string</span>, <span class="ide">int</span>]</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span>(<span class="str">&quot;pairs&quot;</span>, <span class="ide">d</span>: <span class="ide">Dict</span>):</div></div><div class="line"><div class="line-content">  <span class="ide">pairs</span> <span class="op">&lt;-</span> <span class="ide">pair</span> <span class="op">*</span> <span class="op">*</span>(',' <span class="op">*</span> <span class="ide">pair</span>) <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span></div></div><div class="line"><div class="line-content">  <span class="ide">number</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">pair</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">word</span> <span class="op">*</span> '=' <span class="op">*</span> <span class="op">&gt;</span><span class="ide">number</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">d</span>[<span class="op">$</span><span class="num">1</span>] <span class="op">=</span> <span class="ide">parseInt</span>(<span class="op">$</span><span class="num">2</span>)</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">var</span> <span class="ide">words</span>: <span class="ide">Dict</span></div></div><div class="line"><div class="line-content"><span class="ide">doAssert</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;one=1,two=2,three=3,four=4&quot;</span>, <span class="ide">words</span>)<span class="op">.</span><span class="ide">ok</span></div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">words</span></div></div>  </code></pre>
<p>Output:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content">{<span class="str">&quot;two&quot;</span>: <span class="num">2</span>, <span class="str">&quot;three&quot;</span>: <span class="num">3</span>, <span class="str">&quot;one&quot;</span>: <span class="num">1</span>, <span class="str">&quot;four&quot;</span>: <span class="num">4</span>}</div></div>  </code></pre>
<p>A brief explanation of the above code:</p>
<ul>
<li>
<p>The macro <code>peg</code> is used to create a parser object, which uses <code>pairs</code> as the
initial grammar rule to match. The variable <code>d</code> of type <code>Dict</code> will be available
inside the code block parser for storing the parsed data.</p>
</li>
<li>
<p>The rule <code>pairs</code> matches one <code>pair</code>, followed by zero or more times (<code>*</code>) a
comma followed by a <code>pair</code>.</p>
</li>
<li>
<p>The rules <code>word</code> and <code>number</code> match a sequence of one or more (<code>+</code>)
alphabetic characters or digits, respectively. The <code>Alpha</code> and <code>Digit</code> rules
are pre-defined rules matching the character classes <code>{&apos;A&apos;..&apos;Z&apos;,&apos;a&apos;..&apos;z&apos;}</code>
and <code>{&apos;0&apos;..&apos;9&apos;}</code>.</p>
</li>
<li>
<p>The rule <code>pair</code> matches a <code>word</code>, followed by an equals sign (<code>=</code>), followed
by a <code>number</code>.</p>
</li>
<li>
<p>The <code>word</code> and <code>number</code> in the <code>pair</code> rule are captured with the <code>&gt;</code>
operator. The Nim code fragment below this rule is executed for every match,
and stores the captured word and number in the <code>words</code> Nim table.</p>
</li>
</ul>
<h2>Usage</h2>
<p>The <code>patt()</code> and <code>peg()</code> macros can be used to compile parser functions:</p>
<ul>
<li>
<p><code>patt()</code> creates a parser from a single anonymous pattern.</p>
</li>
<li>
<p><code>peg()</code> allows the definition of a set of (potentially recursive) rules
making up a complete grammar.</p>
</li>
</ul>
<p>The result of these macros is an object of the type <code>Parser</code> which can be used
to parse a subject:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">proc</span> <span class="ide">match</span>(<span class="ide">p</span>: <span class="ide">Parser</span>, <span class="ide">s</span>: <span class="ide">string</span>) <span class="op">=</span> <span class="ide">MatchResult</span></div></div><div class="line"><div class="line-content"><span class="kwd">proc</span> <span class="ide">matchFile</span>(<span class="ide">p</span>: <span class="ide">Parser</span>, <span class="ide">fname</span>: <span class="ide">string</span>) <span class="op">=</span> <span class="ide">MatchResult</span></div></div>  </code></pre>
<p>The above <code>match</code> functions returns an object of the type <code>MatchResult</code>:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">MatchResult</span> <span class="op">=</span> <span class="kwd">object</span></div></div><div class="line"><div class="line-content">  <span class="ide">ok</span>: <span class="ide">bool</span></div></div><div class="line"><div class="line-content">  <span class="ide">matchLen</span>: <span class="ide">int</span></div></div><div class="line"><div class="line-content">  <span class="ide">matchMax</span>: <span class="ide">int</span></div></div><div class="line"><div class="line-content">  <span class="op">...</span></div></div>  </code></pre>
<ul>
<li>
<p><code>ok</code>: A boolean indicating if the matching succeeded without error. Note that
a successful match does not imply that <em>all of the subject</em> was matched,
unless the pattern explicitly matches the end-of-string.</p>
</li>
<li>
<p><code>matchLen</code>: The number of input bytes of the subject that successfully
matched.</p>
</li>
<li>
<p><code>matchMax</code>: The highest index into the subject that was reached during
parsing, <em>even if matching was backtracked or did not succeed</em>. This offset
is usually a good indication of the location where the matching error
occurred.</p>
</li>
</ul>
<p>The string captures made during the parsing can be accessed with:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">proc</span> <span class="ide">captures</span>(<span class="ide">m</span>: <span class="ide">MatchResult</span>): <span class="ide">seq</span>[<span class="ide">string</span>]</div></div>  </code></pre>
<h3>Simple patterns</h3>
<p>A simple pattern can be compiled with the <code>patt</code> macro.</p>
<p>For example, the pattern below splits a string by white space:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">patt</span> <span class="op">*</span>(<span class="op">*</span>' ' <span class="op">*</span> <span class="op">&gt;</span> <span class="op">+</span>(<span class="num">1</span><span class="op">-</span>' '))</div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;   one two three &quot;</span>)<span class="op">.</span><span class="ide">captures</span></div></div>  </code></pre>
<p>Output:</p>
<pre>  <code>@[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
</code></pre>
<p>The <code>patt</code> macro can take an optional code block which is used as code block
capture for the pattern:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">var</span> <span class="ide">key</span>, <span class="ide">val</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">p</span> <span class="op">=</span> <span class="ide">patt</span> <span class="op">&gt;+</span><span class="ide">Digit</span> <span class="op">*</span> <span class="str">&quot;=&quot;</span> <span class="op">*</span> <span class="op">&gt;+</span><span class="ide">Alpha</span>:</div></div><div class="line"><div class="line-content">  (<span class="ide">key</span>, <span class="ide">val</span>) <span class="op">=</span> (<span class="op">$</span><span class="num">1</span>, <span class="op">$</span><span class="num">2</span>)</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">assert</span> <span class="ide">p</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;15=fifteen&quot;</span>)<span class="op">.</span><span class="ide">ok</span></div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">key</span>, <span class="str">&quot; = &quot;</span>, <span class="ide">val</span></div></div>  </code></pre>
<h3>Grammars</h3>
<p>The <code>peg</code> macro provides a method to define (recursive) grammars. The first
argument is the name of initial patterns, followed by a list of named patterns.
Patterns can now refer to other patterns by name, allowing for recursion:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;ident&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">lower</span> <span class="op">&lt;-</span> {'a'<span class="op">..</span>'z'}</div></div><div class="line"><div class="line-content">  <span class="ide">ident</span> <span class="op">&lt;-</span> <span class="op">*</span><span class="ide">lower</span></div></div><div class="line"><div class="line-content"><span class="ide">doAssert</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;lowercaseword&quot;</span>)<span class="op">.</span><span class="ide">ok</span></div></div>  </code></pre>
<p>The order in which the grammar patterns are defined affects the generated
parser.
Although NPeg could always reorder, this is a design choice to give the user
more control over the generated parser:</p>
<ul>
<li>
<p>when a pattern <code>P1</code> refers to pattern <code>P2</code> which is defined <em>before</em> <code>P1</code>,
<code>P2</code> will be inlined in <code>P1</code>.  This increases the generated code size, but
generally improves performance.</p>
</li>
<li>
<p>when a pattern <code>P1</code> refers to pattern <code>P2</code> which is defined <em>after</em> <code>P1</code>,
<code>P2</code> will be generated as a subroutine which gets called from <code>P1</code>. This will
reduce code size, but might also result in a slower parser.</p>
</li>
</ul>
<h2>Syntax</h2>
<p>The NPeg syntax is similar to normal PEG notation, but some changes were made
to allow the grammar to be properly parsed by the Nim compiler:</p>
<ul>
<li>NPeg uses prefixes instead of suffixes for <code>*</code>, <code>+</code>, <code>-</code> and <code>?</code>.</li>
<li>Ordered choice uses <code>|</code> instead of <code>/</code> because of operator precedence.</li>
<li>The explicit <code>*</code> infix operator is used for sequences.</li>
</ul>
<p>NPeg patterns and grammars can be composed from the following parts:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">Atoms</span>:</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">   <span class="num">0</span>              <span class="com"># matches always and consumes nothing</span></div></div><div class="line"><div class="line-content">   <span class="num">1</span>              <span class="com"># matches any character</span></div></div><div class="line"><div class="line-content">   <span class="ide">n</span>              <span class="com"># matches exactly n characters</span></div></div><div class="line"><div class="line-content">  'x'             <span class="com"># matches literal character &apos;x&apos;</span></div></div><div class="line"><div class="line-content">  <span class="str">&quot;xyz&quot;</span>           <span class="com"># matches literal string &quot;xyz&quot;</span></div></div><div class="line"><div class="line-content"> i"xyz"           <span class="com"># matches literal string, case insensitive</span></div></div><div class="line"><div class="line-content">  {'x'<span class="op">..</span>'y'}      <span class="com"># matches any character in the range from &apos;x&apos;..&apos;y&apos;</span></div></div><div class="line"><div class="line-content">  {'x','y','z'}   <span class="com"># matches any character from the set</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">Operators</span>:</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">   <span class="ide">P1</span> <span class="op">*</span> <span class="ide">P2</span>        <span class="com"># concatenation</span></div></div><div class="line"><div class="line-content">   <span class="ide">P1</span> <span class="op">|</span> <span class="ide">P2</span>        <span class="com"># ordered choice</span></div></div><div class="line"><div class="line-content">   <span class="ide">P1</span> <span class="op">-</span> <span class="ide">P2</span>        <span class="com"># matches P1 if P2 does not match</span></div></div><div class="line"><div class="line-content">  (<span class="ide">P</span>)             <span class="com"># grouping</span></div></div><div class="line"><div class="line-content">  <span class="op">!</span><span class="ide">P</span>              <span class="com"># matches everything but P</span></div></div><div class="line"><div class="line-content">  <span class="op">&amp;</span><span class="ide">P</span>              <span class="com"># matches P without consuming input</span></div></div><div class="line"><div class="line-content">  <span class="op">?</span><span class="ide">P</span>              <span class="com"># matches P zero or one times</span></div></div><div class="line"><div class="line-content">  <span class="op">*</span><span class="ide">P</span>              <span class="com"># matches P zero or more times</span></div></div><div class="line"><div class="line-content">  <span class="op">+</span><span class="ide">P</span>              <span class="com"># matches P one or more times</span></div></div><div class="line"><div class="line-content">  <span class="op">@</span><span class="ide">P</span>              <span class="com"># search for P</span></div></div><div class="line"><div class="line-content">   <span class="ide">P</span>[<span class="ide">n</span>]           <span class="com"># matches P n times</span></div></div><div class="line"><div class="line-content">   <span class="ide">P</span>[<span class="ide">m</span><span class="op">..</span><span class="ide">n</span>]        <span class="com"># matches P m to n times</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">Precedence</span> <span class="ide">operators</span>:</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  <span class="ide">P</span> <span class="op">^</span> <span class="ide">N</span>           <span class="com"># P is left associative with precedence N</span></div></div><div class="line"><div class="line-content">  <span class="ide">P</span> <span class="op">^^</span> <span class="ide">N</span>          <span class="com"># P is right associative with precedence N</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">String</span> <span class="ide">captures</span>:  </div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  <span class="op">&gt;</span><span class="ide">P</span>              <span class="com"># Captures the string matching  P </span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">Back</span> <span class="ide">references</span>:</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  <span class="ide">R</span>(<span class="str">&quot;tag&quot;</span>, <span class="ide">P</span>)     <span class="com"># Create a named reference for pattern P</span></div></div><div class="line"><div class="line-content">  <span class="ide">R</span>(<span class="str">&quot;tag&quot;</span>)        <span class="com"># Matches the given named reference</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">Error</span> <span class="ide">handling</span>:</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  E"msg"          <span class="com"># Raise an `NPegParseError` exception</span></div></div>  </code></pre>
<p>In addition to the above, NPeg provides the following built-in shortcuts for
common atoms, corresponding to POSIX character classes:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">Alnum</span>  <span class="op">&lt;-</span> {'A'<span class="op">..</span>'Z','a'<span class="op">..</span>'z','0'<span class="op">..</span>'9'}, <span class="com"># Alphanumeric characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Alpha</span>  <span class="op">&lt;-</span> {'A'<span class="op">..</span>'Z','a'<span class="op">..</span>'z'},          <span class="com"># Alphabetic characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Blank</span>  <span class="op">&lt;-</span> {' ','\t'},                   <span class="com"># Space and tab</span></div></div><div class="line"><div class="line-content">  <span class="ide">Cntrl</span>  <span class="op">&lt;-</span> {'\x00'<span class="op">..</span>'\x1f','\x7f'},      <span class="com"># Control characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Digit</span>  <span class="op">&lt;-</span> {'0'<span class="op">..</span>'9'},                   <span class="com"># Digits</span></div></div><div class="line"><div class="line-content">  <span class="ide">Graph</span>  <span class="op">&lt;-</span> {'\x21'<span class="op">..</span>'\x7e'},             <span class="com"># Visible characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Lower</span>  <span class="op">&lt;-</span> {'a'<span class="op">..</span>'z'},                   <span class="com"># Lowercase characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Print</span>  <span class="op">&lt;-</span> {'\x21'<span class="op">..</span>'\x7e',' '},         <span class="com"># Visible characters and spaces</span></div></div><div class="line"><div class="line-content">  <span class="ide">Space</span>  <span class="op">&lt;-</span> {'\9'<span class="op">..</span>'\13',' '},            <span class="com"># Whitespace characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Upper</span>  <span class="op">&lt;-</span> {'A'<span class="op">..</span>'Z'},                   <span class="com"># Uppercase characters</span></div></div><div class="line"><div class="line-content">  <span class="ide">Xdigit</span> <span class="op">&lt;-</span> {'A'<span class="op">..</span>'F','a'<span class="op">..</span>'f','0'<span class="op">..</span>'9'}, <span class="com"># Hexadecimal digits</span></div></div>  </code></pre>
<h3>Atoms</h3>
<p>Atoms are the basic building blocks for a grammar, describing the parts of the
subject that should be matched.</p>
<ul>
<li>
<p>Integer literal: <code>0</code> / <code>1</code> / <code>n</code></p>
<p>The int literal atom <code>n</code> matches exactly n number of bytes. <code>0</code> always
matches, but does not consume any data.</p>
</li>
<li>
<p>Character and string literals: <code>&apos;x&apos;</code> / <code>&quot;xyz&quot;</code> / <code>i&quot;xyz&quot;</code></p>
<p>Characters and strings are literally matched. If a string is prefixed with
<code>i</code>, it will be matched case insensitive.</p>
</li>
<li>
<p>Character sets: <code>{&apos;x&apos;,&apos;y&apos;}</code></p>
<p>Characters set notation is similar to native Nim. A set consists of zero or
more comma separated characters or character ranges.</p>
<pre>  <code class="language-nim"> {&apos;x&apos;..&apos;y&apos;}    # matches any character in the range from &apos;x&apos;..&apos;y&apos;
 {&apos;x&apos;,&apos;y&apos;,&apos;z&apos;} # matches any character from the set &apos;x&apos;, &apos;y&apos;, and &apos;z&apos;
</code></pre>
<p>The set syntax <code>{}</code> is flexible and can take multiple ranges and characters
in one expression, for example <code>{&apos;0&apos;..&apos;9&apos;,&apos;a&apos;..&apos;f&apos;,&apos;A&apos;..&apos;F&apos;}</code>.</p>
</li>
</ul>
<h3>Operators</h3>
<p>NPeg provides various prefix and infix operators. These operators combine or
transform one or more patterns into expressions, building larger patterns.</p>
<ul>
<li>
<p>Concatenation: <code>P1 * P2</code></p>
<pre>  <code>o──[P1]───[P2]──o
</code></pre>
<p>The pattern <code>P1 * P2</code> returns a new pattern that matches only if first <code>P1</code>
matches, followed by <code>P2</code>.</p>
<p>For example, <code>&quot;foo&quot; * &quot;bar&quot;</code> would only match the string <code>&quot;foobar&quot;</code>.</p>
<p>Note: As an alternative for the <code>*</code> asterisk, the unicode glyph <code>∙</code> (&quot;bullet
operator&quot;, 0x2219) can also be used for concatenation.</p>
</li>
<li>
<p>Ordered choice: <code>P1 | P2</code></p>
<pre>  <code>o─┬─[P1]─┬─o
  ╰─[P2]─╯
</code></pre>
<p>The pattern <code>P1 | P2</code> tries to first match pattern <code>P1</code>. If this succeeds,
matching will proceed without trying <code>P2</code>. Only if <code>P1</code> can not be matched,
NPeg will backtrack and try to match <code>P2</code> instead. Once either <code>P1</code> or <code>P2</code> has
matched, the choice will be final (&quot;commited&quot;), and no more backtracking will
be possible for this choice.</p>
<p>For example <code>(&quot;foo&quot; | &quot;bar&quot;) * &quot;fizz&quot;</code> would match both <code>&quot;foofizz&quot;</code> and
<code>&quot;barfizz&quot;</code>.</p>
<p>NPeg optimizes the <code>|</code> operator for characters and character sets: The
pattern <code>&apos;a&apos; | &apos;b&apos; | &apos;c&apos;</code> will be rewritten to a character set
<code>{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;}</code>.</p>
</li>
<li>
<p>Difference: <code>P1 - P2</code></p>
<p>The pattern <code>P1 - P2</code> matches <code>P1</code> <em>only</em> if <code>P2</code> does not match. This is
equivalent to <code>!P2 * P1</code>:</p>
<pre>  <code>   ━━━━
o──[P2]─»─[P1]──o
</code></pre>
<p>NPeg optimizes the <code>-</code> operator for characters and character sets: The
pattern <code>{&apos;a&apos;,&apos;b&apos;,&apos;c&apos;} - &apos;b&apos;</code> will be rewritten to the character set
<code>{&apos;a&apos;,&apos;c&apos;}</code>.</p>
</li>
<li>
<p>Grouping: <code>(P)</code></p>
<p>Brackets are used to group patterns similar to normal arithmetic expressions.</p>
</li>
<li>
<p>Not-predicate: <code>!P</code></p>
<pre>  <code>   ━━━
o──[P]──o
</code></pre>
<p>The pattern <code>!P</code> returns a pattern that matches only if the input does not
match <code>P</code>.
In contrast to most other patterns, this pattern does not consume any input.</p>
<p>A common usage for this operator is the pattern <code>!1</code>, meaning &quot;only succeed
if there is not a single character left to match&quot; - which is only true for
the end of the string.</p>
</li>
<li>
<p>And-predicate: <code>&amp;P</code></p>
<pre>  <code>   ━━━
   ━━━
o──[P]──o
</code></pre>
<p>The pattern <code>&amp;P</code> matches only if the input matches <code>P</code>, but will <em>not</em>
consume any input. This is equivalent to <code>!!P</code>. This is denoted by a double
negation in the railroad diagram, which is not very pretty unfortunately.</p>
</li>
<li>
<p>Optional: <code>?P</code></p>
<pre>  <code>  ╭──»──╮
o─┴─[P]─┴─o
</code></pre>
<p>The pattern <code>?P</code> matches if <code>P</code> can be matched zero or more times, so
essentially succeeds if <code>P</code> either matches or not.</p>
<p>For example, <code>?&quot;foo&quot; * bar&quot;</code> matches both <code>&quot;foobar&quot;</code> and <code>&quot;bar&quot;</code>.</p>
</li>
<li>
<p>Match zero or more times: <code>*P</code></p>
<pre>  <code>  ╭───»───╮
o─┴┬─[P]─┬┴─o
   ╰──«──╯
</code></pre>
<p>The pattern <code>*P</code> tries to match as many occurrences of pattern <code>P</code> as
possible - this operator always behaves <em>greedily</em>.</p>
<p>For example, <code>*&quot;foo&quot; * &quot;bar&quot;</code> matches <code>&quot;bar&quot;</code>, <code>&quot;fooboar&quot;</code>, <code>&quot;foofoobar&quot;</code>,
etc.</p>
</li>
<li>
<p>Match one or more times: <code>+P</code></p>
<pre>  <code>o─┬─[P]─┬─o
  ╰──«──╯
</code></pre>
<p>The pattern <code>+P</code> matches <code>P</code> at least once, but also more times.
It is equivalent to the <code>P * *P</code> - this operator always behave <em>greedily</em>.</p>
</li>
<li>
<p>Search: <code>@P</code></p>
<p>This operator searches for pattern <code>P</code> using an optimized implementation. It
is equivalent to <code>s &lt;- *(1 - P) * P</code>, which can be read as &quot;try to match as
many characters as possible not matching <code>P</code>, and then match <code>P</code>:</p>
<pre>  <code>  ╭─────»─────╮
  │  ━━━      │
o─┴┬─[P]─»─1─┬┴»─[P]──o
   ╰────«────╯
</code></pre>
<p>Note that this operator does not allow capturing the skipped data up to the
match; if this is required you can manually construct a grammar to do this.</p>
</li>
<li>
<p>Match exactly <code>n</code> times: <code>P[n]</code></p>
<p>The pattern <code>P[n]</code> matches <code>P</code> exactly <code>n</code> times.</p>
<p>For example, <code>&quot;foo&quot;[3]</code> only matches the string <code>&quot;foofoofoo&quot;</code>:</p>
<pre>  <code>o──[P]─»─[P]─»─[P]──o
</code></pre>
</li>
<li>
<p>Match <code>m</code> to <code>n</code> times: <code>P[m..n]</code></p>
<p>The pattern <code>P[m..n]</code> matches <code>P</code> at least <code>m</code> and at most <code>n</code> times.</p>
<p>For example, <code>&quot;foo[1,3]&quot;</code> matches <code>&quot;foo&quot;</code>, <code>&quot;foofoo&quot;</code> and <code>&quot;foofoofo&quot;</code>:</p>
<pre>  <code>        ╭──»──╮ ╭──»──╮
o──[P]─»┴─[P]─┴»┴─[P]─┴─o
</code></pre>
</li>
</ul>
<h2>Precedence operators</h2>
<p>Note: This is an experimental feature, the implementation or API might change
in the future.</p>
<p>Precedence operators allows for the construction of &quot;precedence climbing&quot; or
&quot;Pratt parsers&quot; with NPeg. The main use for this feature is building parsers
for programming languages that follow the usual precedence and associativity
rules of arithmetic expressions.</p>
<ul>
<li>Left associative precedence of <code>N</code>: <code>P ^ N</code></li>
</ul>
<pre>  <code>   &lt;1&lt;   
o──[P]──o
</code></pre>
<ul>
<li>Right associative precedence of <code>N</code>: <code>P ^^ N</code></li>
</ul>
<pre>  <code>   &gt;1&gt; 
o──[P]──o
</code></pre>
<p>During parsing NPeg keeps track of the current precedence level of the parsed
expression - the default is <code>0</code> if no precedence has been assigned yet. When
the <code>^</code> operator is matched, either one of the next three cases applies:</p>
<ul>
<li>
<p><code>P ^ N</code> where <code>N &gt; 0</code> and <code>N</code> is lower then the current precedence: in this
case the current precedence is set to <code>N</code> and parsing of pattern <code>P</code>
continues.</p>
</li>
<li>
<p><code>P ^ N</code> where <code>N &gt; 0</code> and <code>N</code> is higher or equal then the current precedence:
parsing will fail and backtrack.</p>
</li>
<li>
<p><code>P ^ 0</code>: resets the current precedence to 0 and continues parsing. This main
use case for this is parsing sub-expressions in parentheses.</p>
</li>
</ul>
<p>The heart of a Prett parser in NPeg would look something like this:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">exp</span> <span class="op">&lt;-</span> <span class="ide">prefix</span> <span class="op">*</span> <span class="op">*</span><span class="ide">infix</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">parenExp</span> <span class="op">&lt;-</span> ( <span class="str">&quot;(&quot;</span> <span class="op">*</span> <span class="ide">exp</span> <span class="op">*</span> <span class="str">&quot;)&quot;</span> ) <span class="op">^</span> <span class="num">0</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">prefix</span> <span class="op">&lt;-</span> <span class="ide">number</span> <span class="op">|</span> <span class="ide">parenExp</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">infix</span> <span class="op">&lt;-</span> {'+','-'}    <span class="op">*</span> <span class="ide">exp</span> <span class="op">^</span>  <span class="num">1</span> <span class="op">|</span></div></div><div class="line"><div class="line-content">         {'*','/'}    <span class="op">*</span> <span class="ide">exp</span> <span class="op">^</span>  <span class="num">2</span> <span class="op">|</span></div></div><div class="line"><div class="line-content">         {'^'}        <span class="op">*</span> <span class="ide">exp</span> <span class="op">^^</span> <span class="num">3</span>:</div></div>  </code></pre>
<p>More extensive documentation will be added later, for now take a look at the
example in <code>tests/precedence.nim</code>.</p>
<h2>Captures</h2>
<pre>  <code>     ╭╶╶╶╶╶╮
s o────[P]────o
     ╰╶╶╶╶╶╯
</code></pre>
<p>NPeg supports a number of ways to capture data when parsing a string.
The various capture methods are described here, including a concise example.</p>
<p>The capture examples below build on the following small PEG, which parses
a comma separated list of key-value pairs:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">const</span> <span class="ide">data</span> <span class="op">=</span> <span class="str">&quot;one=1,two=2,three=3,four=4&quot;</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;pairs&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">pairs</span> <span class="op">&lt;-</span> <span class="ide">pair</span> <span class="op">*</span> <span class="op">*</span>(',' <span class="op">*</span> <span class="ide">pair</span>) <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span></div></div><div class="line"><div class="line-content">  <span class="ide">number</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">pair</span> <span class="op">&lt;-</span> <span class="ide">word</span> <span class="op">*</span> '=' <span class="op">*</span> <span class="ide">number</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">r</span> <span class="op">=</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">data</span>)</div></div>  </code></pre>
<h3>String captures</h3>
<p>The basic method for capturing is marking parts of the peg with the capture
prefix <code>&gt;</code>. During parsing NPeg keeps track of all matches, properly discarding
any matches which were invalidated by backtracking. Only when parsing has fully
succeeded it creates a <code>seq[string]</code> of all matched parts, which is then
returned in the <code>MatchData.captures</code> field.</p>
<p>In the example, the <code>&gt;</code> capture prefix is added to the <code>word</code> and <code>number</code>
rules, causing the matched words and numbers to be appended to the result
capture <code>seq[string]</code>:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;pairs&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">pairs</span> <span class="op">&lt;-</span> <span class="ide">pair</span> <span class="op">*</span> <span class="op">*</span>(',' <span class="op">*</span> <span class="ide">pair</span>) <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span></div></div><div class="line"><div class="line-content">  <span class="ide">number</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">pair</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">word</span> <span class="op">*</span> '=' <span class="op">*</span> <span class="op">&gt;</span><span class="ide">number</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">r</span> <span class="op">=</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">data</span>)</div></div>  </code></pre>
<p>The resulting list of captures is now:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="op">@</span>[<span class="str">&quot;one&quot;</span>, <span class="str">&quot;1&quot;</span>, <span class="str">&quot;two&quot;</span>, <span class="str">&quot;2&quot;</span>, <span class="str">&quot;three&quot;</span>, <span class="str">&quot;3&quot;</span>, <span class="str">&quot;four&quot;</span>, <span class="str">&quot;4&quot;</span>]</div></div>  </code></pre>
<h3>Code block captures</h3>
<p>Code block captures offer the most flexibility for accessing matched data in
NPeg. This allows you to define a grammar with embedded Nim code for handling
the data during parsing.</p>
<p>Note that for code block captures, the Nim code gets executed during parsing,
<em>even if the match is part of a pattern that fails and is later backtracked</em>.</p>
<p>When a grammar rule ends with a colon <code>:</code>, the next indented block in the
grammar is interpreted as Nim code, which gets executed when the rule has been
matched. Any string captures that were made inside the rule are available to
the Nim code in the injected variable <code>capture[]</code> of type <code>seq[Capture]</code>:</p>
<pre>  <code>type Capture = object
  s*: string      # The captured string
  si*: int        # The index of the captured string in the subject
</code></pre>
<p>The total subject matched by the code block rule is available in <code>capture[0]</code>
Any additional explicit <code>&gt;</code> string captures made by the rule or any of its
child rules will be available as <code>capture[1]</code>, <code>capture[2]</code>, ...</p>
<p>For convenience there is syntactic sugar available in the code block capture
blocks:</p>
<ul>
<li>
<p>The variables <code>$0</code> to <code>$9</code> are rewritten to <code>capture[n].s</code> and can be used to
access the captured strings. The <code>$</code> operator uses then usual Nim precedence,
thus these variables might need parentheses or different ordering in some
cases, for example <code>$1.parseInt</code> should be written as <code>parseInt($1)</code>.</p>
</li>
<li>
<p>The variables <code>@0</code> to <code>@9</code> are rewritten to <code>capture[n].si</code> and can be used
to access the offset in the subject of the matched captures.</p>
</li>
</ul>
<p>Example:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">p</span> <span class="op">=</span> <span class="ide">peg</span> <span class="ide">foo</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">foo</span> <span class="op">&lt;-</span> <span class="op">&gt;</span>(<span class="num">1</span> <span class="op">*</span> <span class="op">&gt;</span><span class="num">1</span>) <span class="op">*</span> <span class="num">1</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">echo</span> <span class="str">&quot;$0 = &quot;</span>, <span class="op">$</span><span class="num">0</span></div></div><div class="line"><div class="line-content">    <span class="ide">echo</span> <span class="str">&quot;$1 = &quot;</span>, <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content">    <span class="ide">echo</span> <span class="str">&quot;$2 = &quot;</span>, <span class="op">$</span><span class="num">2</span></div></div><div class="line"><div class="line-content">       </div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">p</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;abc&quot;</span>)<span class="op">.</span><span class="ide">ok</span></div></div>  </code></pre>
<p>Will output</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="op">$</span><span class="num">0</span> <span class="op">=</span> <span class="ide">abc</span></div></div><div class="line"><div class="line-content"><span class="op">$</span><span class="num">1</span> <span class="op">=</span> <span class="ide">ab</span></div></div><div class="line"><div class="line-content"><span class="op">$</span><span class="num">2</span> <span class="op">=</span> <span class="ide">b</span></div></div>  </code></pre>
<p>Code block captures consume all embedded string captures, so these captures
will no longer be available after matching.</p>
<p>A code block capture can also produce captures by calling the <code>push(s: string)</code>
function from the code block. Note that this is an experimental feature and
that the API might change in future versions.</p>
<p>The example has been extended to capture each word and number with the <code>&gt;</code>
string capture prefix. When the <code>pair</code> rule is matched, the attached code block
is executed, which adds the parsed key and value to the <code>words</code> table.</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">from</span> <span class="ide">strutils</span> <span class="kwd">import</span> <span class="ide">parseInt</span></div></div><div class="line"><div class="line-content"><span class="kwd">var</span> <span class="ide">words</span> <span class="op">=</span> <span class="ide">initTable</span>[<span class="ide">string</span>, <span class="ide">int</span>]()</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;pairs&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">pairs</span> <span class="op">&lt;-</span> <span class="ide">pair</span> <span class="op">*</span> <span class="op">*</span>(',' <span class="op">*</span> <span class="ide">pair</span>) <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span></div></div><div class="line"><div class="line-content">  <span class="ide">number</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">pair</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">word</span> <span class="op">*</span> '=' <span class="op">*</span> <span class="op">&gt;</span><span class="ide">number</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">words</span>[<span class="op">$</span><span class="num">1</span>] <span class="op">=</span> <span class="ide">parseInt</span>(<span class="op">$</span><span class="num">2</span>)</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">r</span> <span class="op">=</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">data</span>)</div></div>  </code></pre>
<p>After the parsing finished, the <code>words</code> table will now contain:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content">{<span class="str">&quot;two&quot;</span>: <span class="num">2</span>, <span class="str">&quot;three&quot;</span>: <span class="num">3</span>, <span class="str">&quot;one&quot;</span>: <span class="num">1</span>, <span class="str">&quot;four&quot;</span>: <span class="num">4</span>}</div></div>  </code></pre>
<h4>Custom match validations</h4>
<p>Code block captures can be used for additional validation of a captured string:
the code block can call the functions <code>fail()</code> or <code>validate(bool)</code> to indicate
if the match should succeed or fail. Failing matches are handled as if the
capture itself failed and will result in the usual backtracking. When the
<code>fail()</code> or <code>validate()</code> functions are not called, the match will succeed
implicitly.</p>
<p>For example, the following rule will check if a passed number is a valid
<code>uint8</code> number:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">uint8</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">Digit</span>[<span class="num">1.</span><span class="op">.</span><span class="num">3</span>]:</div></div><div class="line"><div class="line-content">  <span class="kwd">let</span> <span class="ide">v</span> <span class="op">=</span> <span class="ide">parseInt</span>(<span class="op">$</span><span class="ide">a</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">validate</span> <span class="ide">v</span><span class="op">&gt;=</span><span class="num">0</span> <span class="kwd">and</span> <span class="ide">v</span><span class="op">&lt;=</span><span class="num">255</span></div></div>  </code></pre>
<p>The following grammar will cause the whole parse to fail when the <code>error</code> rule
matches:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">error</span> <span class="op">&lt;-</span> <span class="num">0</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">fail</span>()</div></div>  </code></pre>
<p>Note: The Nim code block is running within the NPeg parser context and in
theory could access to its internal state - this could be used to create custom
validator/matcher functions that can inspect the subject string, do lookahead
or lookback, and adjust the subject index to consume input. At the time of
writing, NPeg lacks a formal API or interface for this though, and I am not
sure yet what this should look like - If you are interested in doing this,
contact me so we can discuss the details.</p>
<h4>Passing state</h4>
<p>NPeg allows passing of data of a specific type to the <code>match()</code> function, this
value is then available inside code blocks as a variable. This mitigates the
need for global variables for storing or retrieving data in access captures.</p>
<p>The syntax for passing data in a grammar is:</p>
<pre>  <code>peg(name, identifier: Type)
</code></pre>
<p>For example, the above parser can be rewritten as such:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">type</span> <span class="ide">Dict</span> <span class="op">=</span> <span class="ide">Table</span>[<span class="ide">string</span>, <span class="ide">int</span>]</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span>(<span class="str">&quot;pairs&quot;</span>, <span class="ide">userdata</span>: <span class="ide">Dict</span>):</div></div><div class="line"><div class="line-content">  <span class="ide">pairs</span> <span class="op">&lt;-</span> <span class="ide">pair</span> <span class="op">*</span> <span class="op">*</span>(',' <span class="op">*</span> <span class="ide">pair</span>) <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span></div></div><div class="line"><div class="line-content">  <span class="ide">number</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">pair</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">word</span> <span class="op">*</span> '=' <span class="op">*</span> <span class="op">&gt;</span><span class="ide">number</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">userdata</span>[<span class="op">$</span><span class="num">1</span>] <span class="op">=</span> <span class="ide">parseInt</span>(<span class="op">$</span><span class="num">2</span>)</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">var</span> <span class="ide">words</span>: <span class="ide">Dict</span></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">r</span> <span class="op">=</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">data</span>, <span class="ide">words</span>)</div></div>  </code></pre>
<h3>Backreferences</h3>
<p>Backreferences allow NPeg to match an exact string that matched earlier in the
grammar. This can be useful to match repetitions of the same word, or for
example to match so called here-documents in programming languages.</p>
<p>For this, NPeg offers the <code>R</code> operator with the following two uses:</p>
<ul>
<li>
<p>The <code>R(name, P)</code> pattern creates a named reference for pattern <code>P</code> which can
be referred to by name in other places in the grammar.</p>
</li>
<li>
<p>The pattern <code>R(name)</code> matches the contents of the named reference that
earlier been stored with <code>R(name, P)</code> pattern.</p>
</li>
</ul>
<p>For example, the following rule will match only a string which will have the
same character in the first and last position:</p>
<pre>  <code>patt R(&quot;c&quot;, 1) * *(1 - R(&quot;c&quot;)) * R(&quot;c&quot;) * !1
</code></pre>
<p>The first part of the rule <code>R(&quot;c&quot;, 1)</code> will match any character, and store this
in the named reference <code>c</code>. The second part will match a sequence of zero or
more characters that do not match reference <code>c</code>, followed by reference <code>c</code>.</p>
<h2>More about grammars</h2>
<h3>Ordering of rules in a grammar</h3>
<p>Repetitive inlining of rules might cause a grammar to grow too large, resulting
in a huge executable size and slow compilation. NPeg tries to mitigate this in
two ways:</p>
<ul>
<li>
<p>Patterns that are too large will not be inlined, even if the above ordering
rules apply.</p>
</li>
<li>
<p>NPeg checks the size of the total grammar, and if it thinks it is too large
it will fail compilation with the error message <code>NPeg: grammar too complex</code>.</p>
</li>
</ul>
<p>Check the section &quot;Compile-time configuration&quot; below for more details about too
complex grammars.</p>
<p>The parser size and performance depends on many factors; when performance
and/or code size matters, it pays to experiment with different orderings and
measure the results.</p>
<p>When in doubt, check the generated parser instructions by compiling with the
<code>-d:npegTrace</code> or <code>-d:npegDotDir</code> flags - see the section Tracing and
Debugging for more information.</p>
<p>At this time the upper limit is 4096 rules, this might become a configurable
number in a future release.</p>
<p>For example, the following grammar will not compile because recursive inlining
will cause it to expand to a parser with more then 4^6 = 4096 rules:</p>
<pre>  <code>let p = peg &quot;z&quot;:
  f &lt;- 1
  e &lt;- f * f * f * f
  d &lt;- e * e * e * e
  c &lt;- d * d * d * d
  b &lt;- c * c * c * c
  a &lt;- b * b * b * b
  z &lt;- a * a * a * a
</code></pre>
<p>The fix is to change the order of the rules so that instead of inlining NPeg
will use a calling mechanism:</p>
<pre>  <code>let p = peg &quot;z&quot;:
  z &lt;- a * a * a * a
  a &lt;- b * b * b * b
  b &lt;- c * c * c * c
  c &lt;- d * d * d * d
  d &lt;- e * e * e * e
  e &lt;- f * f * f * f
  f &lt;- 1
</code></pre>
<p>When in doubt check the generated parser instructions by compiling with the
<code>-d:npegTrace</code> flag - see the section Tracing and Debugging for more
information.</p>
<h3>Templates, or parameterized rules</h3>
<p>When building more complex grammars you may find yourself duplicating certain
constructs in patterns over and over again. To avoid code repetition (DRY),
NPeg provides a simple mechanism to allow the creation of parameterized rules.
In good Nim-fashion these rules are called &quot;templates&quot;. Templates are defined
just like normal rules, but have a list of arguments, which are referred to in
the rule. Technically, templates just perform a basic search-and-replace
operation: every occurrence of a named argument is replaced by the exact
pattern passed to the template when called.</p>
<p>For example, consider the following grammar:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">numberList</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Digit</span> <span class="op">*</span> <span class="op">*</span>( ',' <span class="op">*</span> <span class="op">+</span><span class="ide">Digit</span>)</div></div><div class="line"><div class="line-content"><span class="ide">wordList</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span> <span class="op">*</span> <span class="op">*</span>( ',' <span class="op">*</span> <span class="op">+</span><span class="ide">Alpha</span>)</div></div>  </code></pre>
<p>This snippet uses a common pattern twice for matching lists: <code>p * *( &apos;,&apos; * p)</code>.
This matches pattern <code>p</code>, followed by zero or more occurrences of a comma
followed by pattern <code>p</code>. For example, <code>numberList</code> will match the string
<code>1,22,3</code>.</p>
<p>The above example can be parameterized with a template like this:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">commaList</span>(<span class="ide">item</span>) <span class="op">&lt;-</span> <span class="ide">item</span> <span class="op">*</span> <span class="op">*</span>( ',' <span class="op">*</span> <span class="ide">item</span> )</div></div><div class="line"><div class="line-content"><span class="ide">numberList</span> <span class="op">&lt;-</span> <span class="ide">commaList</span>(<span class="op">+</span><span class="ide">Digit</span>)</div></div><div class="line"><div class="line-content"><span class="ide">wordList</span> <span class="op">&lt;-</span> <span class="ide">commaList</span>(<span class="op">+</span><span class="ide">Alpha</span>)</div></div>  </code></pre>
<p>Here the template <code>commaList</code> is defined, and any occurrence of its argument
&apos;item&apos; will be replaced with the patterns passed when calling the template.
This template is used to define the more complex patterns <code>numberList</code> and
<code>wordList</code>.</p>
<p>Templates may invoke other templates recursively; for example the above can
even be further generalized:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">list</span>(<span class="ide">item</span>, <span class="ide">sep</span>) <span class="op">&lt;-</span> <span class="ide">item</span> <span class="op">*</span> <span class="op">*</span>( <span class="ide">sep</span> <span class="op">*</span> <span class="ide">item</span> )</div></div><div class="line"><div class="line-content"><span class="ide">commaList</span>(<span class="ide">item</span>) <span class="op">&lt;-</span> <span class="ide">list</span>(<span class="ide">item</span>, ',')</div></div><div class="line"><div class="line-content"><span class="ide">numberList</span> <span class="op">&lt;-</span> <span class="ide">commaList</span>(<span class="op">+</span><span class="ide">Digit</span>)</div></div><div class="line"><div class="line-content"><span class="ide">wordList</span> <span class="op">&lt;-</span> <span class="ide">commaList</span>(<span class="op">+</span><span class="ide">Alpha</span>)</div></div>  </code></pre>
<h3>Composing grammars with libraries</h3>
<p>For simple grammars it is usually fine to build all patterns from scratch from
atoms and operators, but for more complex grammars it makes sense to define
reusable patterns as basic building blocks.</p>
<p>For this, NPeg keeps track of a global library of patterns and templates. The
<code>grammar</code> macro can be used to add rules or templates to this library. All
patterns in the library will be stored with a <em>qualified</em> identifier in the
form <code>libraryname.patternname</code>, by which they can be referred to at a later
time.</p>
<p>For example, the following fragment defines three rules in the library with the
name <code>number</code>. The rules will be stored in the global library and are referred
to in the peg by their qualified names <code>number.dec</code>, <code>number.hex</code> and
<code>number.oct</code>:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">grammar</span> <span class="str">&quot;number&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">dec</span> <span class="op">&lt;-</span> {'1'<span class="op">..</span>'9'} <span class="op">*</span> <span class="op">*</span>{'0'<span class="op">..</span>'9'}</div></div><div class="line"><div class="line-content">  <span class="ide">hex</span> <span class="op">&lt;-</span> i"0x" <span class="op">*</span> <span class="op">+</span>{'0'<span class="op">..</span>'9','a'<span class="op">..</span>'f','A'<span class="op">..</span>'F'}</div></div><div class="line"><div class="line-content">  <span class="ide">oct</span> <span class="op">&lt;-</span> '0' <span class="op">*</span> <span class="op">*</span>{'0'<span class="op">..</span>'9'}</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">p</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;line&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">line</span> <span class="op">&lt;-</span> <span class="ide">int</span> <span class="op">*</span> <span class="op">*</span>(<span class="str">&quot;,&quot;</span> <span class="op">*</span> <span class="ide">int</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">int</span> <span class="op">&lt;-</span> <span class="ide">number</span><span class="op">.</span><span class="ide">dec</span> <span class="op">|</span> <span class="ide">number</span><span class="op">.</span><span class="ide">hex</span> <span class="op">|</span> <span class="ide">number</span><span class="op">.</span><span class="ide">oct</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">r</span> <span class="op">=</span> <span class="ide">p</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;123,0x42,0644&quot;</span>)</div></div>  </code></pre>
<p>NPeg offers a number of pre-defined libraries for your convenience, these can
be found in the <code>npeg/lib</code> directory. A library an be imported with the regular
Nim <code>import</code> statement, all rules defined in the imported file will then be
added to NPeg&apos;s global pattern library. For example:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">import</span> <span class="ide">npeg</span><span class="op">/</span><span class="ide">lib</span><span class="op">/</span><span class="ide">uri</span></div></div>  </code></pre>
<p>Note that templates defined in libraries do not implicitly bind the the rules
from that grammar; instead, you need to explicitly qualify the rules used in
the template to refer to the grammar. For example:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">grammar</span> <span class="str">&quot;foo&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">open</span> <span class="op">&lt;-</span> <span class="str">&quot;(&quot;</span></div></div><div class="line"><div class="line-content">  <span class="ide">close</span> <span class="op">&lt;-</span> <span class="str">&quot;)&quot;</span></div></div><div class="line"><div class="line-content">  <span class="ide">inBrackets</span>(<span class="ide">body</span>): <span class="ide">foo</span><span class="op">.</span><span class="ide">open</span> <span class="op">*</span> <span class="ide">body</span> <span class="op">*</span> <span class="ide">foo</span><span class="op">.</span><span class="ide">close</span></div></div>  </code></pre>
<h3>Library rule overriding/shadowing</h3>
<p>To allow the user to add custom captures to imported grammars or rules, it is
possible to <em>override</em> or <em>shadow</em> an existing rule in a grammar.</p>
<p>Overriding will replace the rule from the library with the provided new rule,
allowing the caller to change parts of an imported grammar. A overridden rule
is allowed to reference the original rule by name, which will cause the new
rule to <em>shadow</em> the original rule. This will effectively rename the original
rule and replace it with the newly defined rule which will call the original
referred rule.</p>
<p>For example, the following snippet will reuse the grammar from the <code>uri</code>
library and capture some parts of the URI in a Nim object:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">import</span> <span class="ide">npeg</span><span class="op">/</span><span class="ide">lib</span><span class="op">/</span><span class="ide">uri</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">type</span> <span class="ide">Uri</span> <span class="op">=</span> <span class="kwd">object</span></div></div><div class="line"><div class="line-content">  <span class="ide">host</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content">  <span class="ide">scheme</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content">  <span class="ide">path</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content">  <span class="ide">port</span>: <span class="ide">int</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">var</span> <span class="ide">myUri</span>: <span class="ide">Uri</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;line&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">line</span> <span class="op">&lt;-</span> <span class="ide">uri</span><span class="op">.</span><span class="ide">URI</span></div></div><div class="line"><div class="line-content">  <span class="ide">uri</span><span class="op">.</span><span class="ide">scheme</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">uri</span><span class="op">.</span><span class="ide">scheme</span>: <span class="ide">myUri</span><span class="op">.</span><span class="ide">scheme</span> <span class="op">=</span> <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">uri</span><span class="op">.</span><span class="ide">host</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">uri</span><span class="op">.</span><span class="ide">host</span>:     <span class="ide">myUri</span><span class="op">.</span><span class="ide">host</span> <span class="op">=</span> <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">uri</span><span class="op">.</span><span class="ide">port</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">uri</span><span class="op">.</span><span class="ide">port</span>:     <span class="ide">myUri</span><span class="op">.</span><span class="ide">port</span> <span class="op">=</span> <span class="ide">parseInt</span>(<span class="op">$</span><span class="num">1</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">uri</span><span class="op">.</span><span class="ide">path</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">uri</span><span class="op">.</span><span class="ide">path</span>:     <span class="ide">myUri</span><span class="op">.</span><span class="ide">path</span> <span class="op">=</span> <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;http://nim-lang.org:8080/one/two/three&quot;</span>)</div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">myUri</span>  <span class="com"># --&gt; (host: &quot;nim-lang.org&quot;, scheme: &quot;http&quot;, path: &quot;/one/two/three&quot;, port: 8080)</span></div></div>  </code></pre>
<h2>Error handling</h2>
<p>NPeg offers a number of ways to handle errors during parsing a subject string;
what method best suits your parser depends on your requirements.</p>
<h3>MatchResult</h3>
<p>The most simple way to handle errors is to inspect the <code>MatchResult</code> object
that is returned by the <code>match()</code> proc:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">MatchResult</span> <span class="op">=</span> <span class="kwd">object</span></div></div><div class="line"><div class="line-content">  <span class="ide">ok</span>: <span class="ide">bool</span></div></div><div class="line"><div class="line-content">  <span class="ide">matchLen</span>: <span class="ide">int</span></div></div><div class="line"><div class="line-content">  <span class="ide">matchMax</span>: <span class="ide">int</span></div></div>  </code></pre>
<p>The <code>ok</code> field in the <code>MatchResult</code> indicates if the parser was successful:
when the complete pattern has been matched this value will be set to <code>true</code>,
if the complete pattern did not match the subject the value will be <code>false</code>.</p>
<p>In addition to the <code>ok</code> field, the <code>matchMax</code> field indicates the maximum
offset into the subject the parser was able to match the string. If the
matching succeeded <code>matchMax</code> equals the total length of the subject, if the
matching failed, the value of <code>matchMax</code> is usually a good indication of where
in the subject string the error occurred:</p>
<pre>  <code>let a = patt 4
let r = a.match(&quot;123&quot;)
if not r.ok:
  echo &quot;Parsing failed at position &quot;, r.matchMax
</code></pre>
<h3>NpegParseError exceptions</h3>
<p>When, during matching, the parser reaches an <code>E&quot;message&quot;</code> atom in the grammar,
NPeg will raise an <code>NPegParseError</code> exception with the given message.
The typical use case for this atom is to be combine with the ordered choice <code>|</code>
operator to generate helpful error messages.
The following example illustrates this:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;list&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">list</span> <span class="op">&lt;-</span> <span class="ide">word</span> <span class="op">*</span> <span class="op">*</span>(<span class="ide">comma</span> <span class="op">*</span> <span class="ide">word</span>) <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">Alpha</span> <span class="op">|</span> E"expected word"</div></div><div class="line"><div class="line-content">  <span class="ide">comma</span> <span class="op">&lt;-</span> ',' <span class="op">|</span> E"expected comma"</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">try</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">echo</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;one,two;three&quot;</span>)</div></div><div class="line"><div class="line-content"><span class="kwd">except</span> <span class="ide">NPegParseError</span> <span class="kwd">as</span> <span class="ide">e</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">echo</span> <span class="str">&quot;Parsing failed at position &quot;</span>, <span class="ide">e</span><span class="op">.</span><span class="ide">matchMax</span>, <span class="str">&quot;: &quot;</span>, <span class="ide">e</span><span class="op">.</span><span class="ide">msg</span></div></div>  </code></pre>
<p>The rule <code>comma</code> tries to match the literal <code>&apos;,&apos;</code>. If this can not be matched,
the rule <code>E&quot;expected comma&quot;</code> will match instead, where <code>E</code> will raise an
<code>NPegParseError</code> exception.</p>
<p>The <code>NPegParseError</code> type contains the same two fields as <code>MatchResult</code> to
indicate where in the subject string the match failed: <code>matchLen</code> and
<code>matchMax</code>, which can be used as an indication of the location of the parse
error:</p>
<pre>  <code>Parsing failed at position 7: expected comma
</code></pre>
<h3>Other exceptions</h3>
<p>NPeg can raise a number of other exception types during parsing:</p>
<ul>
<li>
<p><code>NPegParseError</code>: described in the previous section</p>
</li>
<li>
<p><code>NPegStackOverflowError</code>: a stack overflow occured in the backtrace
or call stack; this is usually an indication of a faulty or too complex
grammar.</p>
</li>
<li>
<p><code>NPegUnknownBackrefError</code>: An unknown back reference identifier is used in an
<code>R()</code> rule.</p>
</li>
<li>
<p><code>NPegCaptureOutOfRangeError</code>: A code block capture tries to access a capture
that is not available using the <code>$</code> notation or by accessing the <code>capture[]</code>
seq.</p>
</li>
</ul>
<p>All the above errors are inherited from the generic <code>NPegException</code> object.</p>
<h3>Parser stack trace</h3>
<p>If an exception is raised from within an NPeg parser - either by the <code>E</code> atom
or by nim code in a code block capture - NPeg will augment the Nim stack trace
with frames indicating where in the grammar the exception occured.</p>
<p>The above example will generate the following stack trace, note the last two
entries which are added by NPeg and show the rules in which the exception
occured:</p>
<pre>  <code>/tmp/list.nim(9)         list
./npeg/src/npeg.nim(142) match
./npeg/src/npeg.nim(135) match
/tmp/flop.nim(4)         list &lt;- word * *(comma * word) * eof
/tmp/flop.nim(7)         word &lt;- +{&apos;a&apos; .. &apos;z&apos;} | E&quot;expected word&quot;
Error: unhandled exception: Parsing error at #14: &quot;expected word&quot; [NPegParseError]
</code></pre>
<p>Note: this requires Nim &apos;devel&apos; or version &gt; 1.6.x; on older versions you can
use <code>-d:npegStackTrace</code> to make NPeg dump the stack to stdout.</p>
<h2>Advanced topics</h2>
<h3>Parsing other types then strings</h3>
<p>Note: This is an experimental feature, the implementation or API might change
in the future.</p>
<p>NPeg was originally designed to parse strings like a regular PEG engine, but
has since evolved into a generic parser that can parse any subject of type
<code>openArray[T]</code>. This section describes how to use this feature.</p>
<ul>
<li>
<p>The <code>peg()</code> macro must be passed an additional argument specifying the base
type <code>T</code> of the subject; the generated parser will then parse a subject of
type <code>openArray[T]</code>. When not given, the default type is <code>char</code>, and the parser
parsers <code>openArray[char]</code>, or more typically, <code>string</code>.</p>
</li>
<li>
<p>When matching non-strings, some of the usual atoms like strings or character
sets do not make sense in a grammar, instead the grammar uses literal atoms.
Literals can be specified in square brackets and are interpreted as any Nim
code: <code>[foo]</code>, <code>[1+1]</code> or <code>[&quot;foo&quot;]</code> are all valid literals.</p>
</li>
<li>
<p>When matching non-strings, captures will be limited to only a single element
of the base type, as this makes more sense when parsing a token stream.</p>
</li>
</ul>
<p>For an example of this feature check the example in <code>tests/lexparse.nim</code> - this
implements a classic parser with separate lexing and parsing stages.</p>
<h2>Some notes on using PEGs</h2>
<h3>Anchoring and searching</h3>
<p>Unlike regular expressions, PEGs are always matched in <em>anchored</em> mode only:
the defined pattern is matched from the start of the subject string.
For example, the pattern <code>&quot;bar&quot;</code> does not match the string <code>&quot;foobar&quot;</code>.</p>
<p>To search for a pattern in a stream, a construct like this can be used:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">p</span> <span class="op">&lt;-</span> <span class="str">&quot;bar&quot;</span></div></div><div class="line"><div class="line-content"><span class="ide">search</span> <span class="op">&lt;-</span> <span class="ide">p</span> <span class="op">|</span> <span class="num">1</span> <span class="op">*</span> <span class="ide">search</span></div></div>  </code></pre>
<p>The above grammar first tries to match pattern <code>p</code>, or if that fails, matches
any character <code>1</code> and recurs back to itself. Because searching is a common
operation, NPeg provides the builtin <code>@P</code> operator for this.</p>
<h3>Complexity and performance</h3>
<p>Although it is possible to write patterns with exponential time complexity for
NPeg, they are much less common than in regular expressions, thanks to the
limited backtracking. In particular, patterns written without grammatical rules
always have a worst-case time <code>O(n^k)</code> (and space <code>O(k)</code>, which is constant for
a given pattern), where <code>k</code> is the pattern&apos;s star height. Moreover, NPeg has a
simple and clear performance model that allows programmers to understand and
predict the time complexity of their patterns. The model also provides a firm
basis for pattern optimizations.</p>
<p>(Adapted from Ierusalimschy, &quot;A Text Pattern-Matching Tool based on Parsing
Expression Grammars&quot;, 2008)</p>
<h3>End of string</h3>
<p>PEGs do not care what is in the subject string after the matching succeeds. For
example, the rule <code>&quot;foo&quot;</code> happily matches the string <code>&quot;foobar&quot;</code>. To make sure
the pattern matches the end of string, this has to be made explicit in the
pattern.</p>
<p>The idiomatic notation for this is <code>!1</code>, meaning &quot;only succeed if there is not
a single character left to match&quot; - which is only true for the end of the
string.</p>
<h3>Non-consuming atoms and captures</h3>
<p>The lookahead(<code>&amp;</code>) and not(<code>!</code>) operators may not consume any input, and make
sure that after matching the internal parsing state of the parser is reset to
as is was before the operator was started, including the state of the captures.
This means that any captures made inside a <code>&amp;</code> and <code>!</code> block also are
discarded. It is possible however to capture the contents of a non-consuming
block with a code block capture, as these are <em>always</em> executed, even when the
parser state is rolled back afterwards.</p>
<h3>Left recursion</h3>
<p>NPeg does not support left recursion (this applies to PEGs in general). For
example, the rule</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">A</span> <span class="op">&lt;-</span> <span class="ide">A</span> <span class="op">|</span> 'a'</div></div>  </code></pre>
<p>will cause an infinite loop because it allows for left-recursion of the
non-terminal <code>A</code>.</p>
<p>Similarly, the grammar</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="ide">A</span> <span class="op">&lt;-</span> <span class="ide">B</span> <span class="op">|</span> 'a' <span class="ide">A</span></div></div><div class="line"><div class="line-content"><span class="ide">B</span> <span class="op">&lt;-</span> <span class="ide">A</span></div></div>  </code></pre>
<p>is problematic because it is mutually left-recursive through the non-terminal
<code>B</code>.</p>
<p>Note that loops of patterns that can match the empty string will not result in
the expected behavior. For example, the rule <code>*0</code> will cause the parser to
stall and go into an infinite loop.</p>
<h3>UTF-8 / Unicode</h3>
<p>NPeg has no built-in support for Unicode or UTF-8, instead is simply able to
parse UTF-8 documents just as like any other string. NPeg comes with a simple
UTF-8 grammar library which should simplify common operations like matching a
single code point or character class. The following grammar splits an UTF-8
document into separate characters/glyphs by using the <code>utf8.any</code> rule:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">import</span> <span class="ide">npeg</span><span class="op">/</span><span class="ide">lib</span><span class="op">/</span><span class="ide">utf8</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">p</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;line&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">line</span> <span class="op">&lt;-</span> <span class="op">+</span><span class="ide">char</span></div></div><div class="line"><div class="line-content">  <span class="ide">char</span> <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">utf8</span><span class="op">.</span><span class="ide">any</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">r</span> <span class="op">=</span> <span class="ide">p</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;γνωρίζω&quot;</span>)</div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">r</span><span class="op">.</span><span class="ide">captures</span>()   <span class="com"># --&gt; @[&quot;γ&quot;, &quot;ν&quot;, &quot;ω&quot;, &quot;ρ&quot;, &quot;ί&quot;, &quot;ζ&quot;, &quot;ω&quot;]</span></div></div>  </code></pre>
<h2>Tracing and debugging</h2>
<h3>Syntax diagrams</h3>
<p>When compiled with <code>-d:npegGraph</code>, NPeg will dump
<a href="https://en.wikipedia.org/wiki/Syntax_diagram">syntax diagrams</a>
(also known as railroad diagrams) for all parsed rules.</p>
<p>Syntax diagrams are sometimes helpful to understand or debug a grammar, or to
get more insight in a grammars&apos; complexity.</p>
<pre>  <code>                              ╭─────────»──────────╮                     
                              │      ╭─────»──────╮│                     
                ╭╶╶╶╶╶╶╶╶╶╶╮  │      │  ━━━━      ││         ╭╶╶╶╶╶╶╶╮   
inf o──&quot;INF:&quot;─»───[number]───»┴─&quot;,&quot;─»┴┬─[lf]─»─1─┬┴┴»─[lf]─»───[url]────o
                ╰╶╶╶╶╶╶╶╶╶╶╯          ╰────«─────╯           ╰╶╶╶╶╶╶╶╯   
</code></pre>
<ul>
<li>Optionals (<code>?</code>) are indicated by a forward arrow overhead.</li>
<li>Repeats (&apos;+&apos;) are indicated by a backwards arrow underneath.</li>
<li>Literals (strings, chars, sets) are printed in purple.</li>
<li>Non-terminals are printed in cyan between square brackets.</li>
<li>Not-predicates (<code>!</code>) are overlined in red. Note that the diagram does not
make it clear that the input for not-predicates is not consumed.</li>
<li>Captures are boxed in a gray rectangle, optionally including the capture
name.</li>
</ul>
<p><a href="/doc/example-railroad.png">Here</a> is a a larger example of an URL parser.</p>
<h3>Grammar graphs</h3>
<p>NPeg can generate a graphical representation of a grammar to show the relations
between rules. The generated output is a <code>.dot</code> file which can be processed by
the Graphviz tool to generate an actual image file.</p>
<p>When compiled with <code>-d:npegDotDir=&lt;PATH&gt;</code>, NPeg will generate a <code>.dot</code> file for
each grammar in the code and write it to the given directory.</p>
<p>  <img src="/doc/example-graph.png" style="max-width: 100%;" alt="graph" /></p>
<ul>
<li>
<p>Edge colors represent the rule relation:
grey=inline, blue=call, green=builtin</p>
</li>
<li>
<p>Rule colors represent the relative size/complexity of a rule:
black=&lt;10, orange=10..100, red=&gt;100</p>
</li>
</ul>
<p>Large rules result in larger generated code and slow compile times. Rule size
can generally be decreased by changing the rule order in a grammar to allow
NPeg to call rules instead of inlining them.</p>
<h3>Tracing</h3>
<p>When compiled with <code>-d:npegTrace</code>, NPeg will dump its intermediate
representation of the compiled PEG, and will dump a trace of the execution
during matching. These traces can be used for debugging or optimization of a
grammar.</p>
<p>For example, the following program:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;line&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">space</span> <span class="op">&lt;-</span> ' '</div></div><div class="line"><div class="line-content">  <span class="ide">line</span> <span class="op">&lt;-</span> <span class="ide">word</span> <span class="op">*</span> <span class="op">*</span>(<span class="ide">space</span> <span class="op">*</span> <span class="ide">word</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">word</span> <span class="op">&lt;-</span> <span class="op">+</span>{'a'<span class="op">..</span>'z'}</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">discard</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;one two&quot;</span>)</div></div>  </code></pre>
<p>will output the following intermediate representation at compile time. From
the IR it can be seen that the <code>space</code> rule has been inlined in the <code>line</code>
rule, but that the <code>word</code> rule has been emitted as a subroutine which gets
called from <code>line</code>:</p>
<pre>  <code>line:
   0: line           opCall 6 word        word
   1: line           opChoice 5           *(space * word)
   2:  space         opStr &quot; &quot;            &apos; &apos;
   3: line           opCall 6 word        word
   4: line           opPartCommit 2       *(space * word)
   5:                opReturn

word:
   6: word           opSet &apos;{&apos;a&apos;..&apos;z&apos;}&apos;   {&apos;a&apos; .. &apos;z&apos;}
   7: word           opSpan &apos;{&apos;a&apos;..&apos;z&apos;}&apos;  +{&apos;a&apos; .. &apos;z&apos;}
   8:                opReturn
</code></pre>
<p>At runtime, the following trace is generated. The trace consists of a number
of columns:</p>
<ol>
<li>The current instruction pointer, which maps to the compile time dump.</li>
<li>The index into the subject.</li>
<li>The substring of the subject.</li>
<li>The name of the rule from which this instruction originated.</li>
<li>The instruction being executed.</li>
<li>The backtrace stack depth.</li>
</ol>
<pre>  <code>  0|  0|one two                 |line           |call -&gt; word:6                          |
  6|  0|one two                 |word           |set {&apos;a&apos;..&apos;z&apos;}                          |
  7|  1|ne two                  |word           |span {&apos;a&apos;..&apos;z&apos;}                         |
  8|  3| two                    |               |return                                  |
  1|  3| two                    |line           |choice -&gt; 5                             |
  2|  3| two                    | space         |chr &quot; &quot;                                 |*
  3|  4|two                     |line           |call -&gt; word:6                          |*
  6|  4|two                     |word           |set {&apos;a&apos;..&apos;z&apos;}                          |*
  7|  5|wo                      |word           |span {&apos;a&apos;..&apos;z&apos;}                         |*
  8|  7|                        |               |return                                  |*
  4|  7|                        |line           |pcommit -&gt; 2                            |*
  2|  7|                        | space         |chr &quot; &quot;                                 |*
   |  7|                        |               |fail                                    |*
  5|  7|                        |               |return (done)                           |
</code></pre>
<p>The exact meaning of the IR instructions is not discussed here.</p>
<h2>Compile-time configuration</h2>
<p>NPeg has a number of configurable setting which can be configured at compile
time by passing flags to the compiler. The default values should be ok in most
cases, but if you ever run into one of those limits you are free to configure
those to your liking:</p>
<ul>
<li>
<p><code>-d:npegPattMaxLen=N</code> This is the maximum allowed length of NPeg&apos;s internal
representation of a parser, before it gets translated to Nim code. The reason
to check for an upper limit is that some grammars can grow exponentially by
inlining of patterns, resulting in slow compile times and oversized
executable size. (default: 4096)</p>
</li>
<li>
<p><code>-d:npegInlineMaxLen=N</code> This is the maximum allowed length of a pattern to be
inlined. Inlining generally results in a faster parser, but also increases
code size. It is valid to set this value to 0; in that case NPeg will never
inline patterns and use a calling mechanism instead, this will result in the
smallest code size. (default: 50)</p>
</li>
<li>
<p><code>-d:npegRetStackSize=N</code> Maximum allowed depth of the return stack for the
parser. The default value should be high enough for practical purposes, the
stack depth is only limited to detect invalid grammars. (default: 1024)</p>
</li>
<li>
<p><code>-d:npegBackStackSize=N</code> Maximum allowed depth of the backtrace stack for the
parser. The default value should be high enough for practical purposes, the
stack depth is only limited to detect invalid grammars. (default: 1024)</p>
</li>
<li>
<p><code>-d:npegGcsafe</code> This is a workaround for the case where NPeg needs to be used
from a <code>{.gcsafe.}</code> context when using threads. This will mark the generated
matching function to be <code>{.gcsafe.}</code>.</p>
</li>
</ul>
<h2>Tracing and debugging</h2>
<p>NPeg has a number of compile time flags to enable tracing and debugging of the
generated parser:</p>
<ul>
<li>
<p><code>-d:npegTrace</code>: Enable compile time and run time tracing. Please refer to the
section &apos;Tracing&apos; for more details.</p>
</li>
<li>
<p><code>-d:npegGraph</code>: Dump syntax diagrams of all parsed rules at compile time.</p>
</li>
</ul>
<p>These flags are meant for debugging NPeg itself, and are typically not useful
to the end user:</p>
<ul>
<li>
<p><code>-d:npegDebug</code>: Enable more debug info. Meant for NPeg development debugging
purposes only.</p>
</li>
<li>
<p><code>-d:npegExpand</code>: Dump the generated Nim code for all parsers defined in the
program. Meant for NPeg development debugging purposes only.</p>
</li>
<li>
<p><code>-d:npegStacktrace</code>: When enabled, NPeg will dump a stack trace of the
current position in the parser when an exception is thrown by NPeg itself or
by Nim code in code block captures.</p>
</li>
</ul>
<h2>Random stuff and frequently asked questions</h2>
<h3>Why does NPeg not support regular PEG syntax?</h3>
<p>The NPeg syntax is similar, but not exactly the same as the official PEG
syntax: it uses some different operators, and prefix instead of postfix
operators. The reason for this is that the NPeg grammar is parsed by a Nim
macro in order to allow code block captures to embed Nim code, which puts some
limitations on the available syntax. Also, NPeg&apos;s operators are chosen so that
they have the right precedence for PEGs.</p>
<p>The result is that the grammer itself is expressed as valid Nim, which has the
nice side effect of allowing syntax highlighting and code completion work with
your favorite editor.</p>
<h3>Can NPeg be used to parse EBNF grammars?</h3>
<p>Almost, but not quite. Although PEGS and EBNF look quite similar, there are
some subtle but important differences which do not allow a literal translation
from EBNF to PEG. Notable differences are left recursion and ordered choice.
Also, see &quot;From EBNF to PEG&quot; from Roman R. Redziejowski.</p>
<h3>NPeg and generic functions</h3>
<p>Nim&apos;s macro system is sometimes finicky and not well defined, and NPeg seems to
push it to the limit. This means that you might run into strange and
unexpected issues, especially when mixing NPeg with generic code.</p>
<p>If you run into weird error messages that do not seem to make sense when using
NPeg from generic procs, check the links below for more information and
possible workarounds:</p>
<ul>
<li>https://github.com/nim-lang/Nim/issues/22740</li>
<li>https://github.com/zevv/npeg/issues/68</li>
</ul>
<h2>Examples</h2>
<h3>Parsing arithmetic expressions</h3>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;line&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">exp</span>      <span class="op">&lt;-</span> <span class="ide">term</span>   <span class="op">*</span> <span class="op">*</span>( ('+'<span class="op">|</span>'-') <span class="op">*</span> <span class="ide">term</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">term</span>     <span class="op">&lt;-</span> <span class="ide">factor</span> <span class="op">*</span> <span class="op">*</span>( ('*'<span class="op">|</span>'/') <span class="op">*</span> <span class="ide">factor</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">factor</span>   <span class="op">&lt;-</span> <span class="op">+</span>{'0'<span class="op">..</span>'9'} <span class="op">|</span> ('(' <span class="op">*</span> <span class="ide">exp</span> <span class="op">*</span> ')')</div></div><div class="line"><div class="line-content">  <span class="ide">line</span>     <span class="op">&lt;-</span> <span class="ide">exp</span> <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">doAssert</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="str">&quot;3*(4+15)+2&quot;</span>)<span class="op">.</span><span class="ide">ok</span></div></div>  </code></pre>
<h3>A complete JSON parser</h3>
<p>The following PEG defines a complete parser for the JSON language - it will not
produce any captures, but simple traverse and validate the document:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">s</span> <span class="op">=</span> <span class="ide">peg</span> <span class="str">&quot;doc&quot;</span>:</div></div><div class="line"><div class="line-content">  <span class="ide">S</span>              <span class="op">&lt;-</span> <span class="op">*</span><span class="ide">Space</span></div></div><div class="line"><div class="line-content">  <span class="ide">jtrue</span>          <span class="op">&lt;-</span> <span class="str">&quot;true&quot;</span></div></div><div class="line"><div class="line-content">  <span class="ide">jfalse</span>         <span class="op">&lt;-</span> <span class="str">&quot;false&quot;</span></div></div><div class="line"><div class="line-content">  <span class="ide">jnull</span>          <span class="op">&lt;-</span> <span class="str">&quot;null&quot;</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  <span class="ide">unicodeEscape</span>  <span class="op">&lt;-</span> 'u' <span class="op">*</span> <span class="ide">Xdigit</span>[<span class="num">4</span>]</div></div><div class="line"><div class="line-content">  <span class="ide">escape</span>         <span class="op">&lt;-</span> '\\' <span class="op">*</span> ({ '{', '"', '|', '\\', 'b', 'f', 'n', 'r', 't' } <span class="op">|</span> <span class="ide">unicodeEscape</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">stringBody</span>     <span class="op">&lt;-</span> <span class="op">?</span><span class="ide">escape</span> <span class="op">*</span> <span class="op">*</span>( <span class="op">+</span>( {'\x20'<span class="op">..</span>'\xff'} <span class="op">-</span> {'"'} <span class="op">-</span> {'\\'}) <span class="op">*</span> <span class="op">*</span><span class="ide">escape</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">jstring</span>         <span class="op">&lt;-</span> <span class="op">?</span><span class="ide">S</span> <span class="op">*</span> '"' <span class="op">*</span> <span class="ide">stringBody</span> <span class="op">*</span> '"' <span class="op">*</span> <span class="op">?</span><span class="ide">S</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  <span class="ide">minus</span>          <span class="op">&lt;-</span> '-'</div></div><div class="line"><div class="line-content">  <span class="ide">intPart</span>        <span class="op">&lt;-</span> '0' <span class="op">|</span> (<span class="ide">Digit</span><span class="op">-</span>'0') <span class="op">*</span> <span class="op">*</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">fractPart</span>      <span class="op">&lt;-</span> <span class="str">&quot;.&quot;</span> <span class="op">*</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">expPart</span>        <span class="op">&lt;-</span> ( 'e' <span class="op">|</span> 'E' ) <span class="op">*</span> <span class="op">?</span>( '+' <span class="op">|</span> '-' ) <span class="op">*</span> <span class="op">+</span><span class="ide">Digit</span></div></div><div class="line"><div class="line-content">  <span class="ide">jnumber</span>         <span class="op">&lt;-</span> <span class="op">?</span><span class="ide">minus</span> <span class="op">*</span> <span class="ide">intPart</span> <span class="op">*</span> <span class="op">?</span><span class="ide">fractPart</span> <span class="op">*</span> <span class="op">?</span><span class="ide">expPart</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content">  <span class="ide">doc</span>            <span class="op">&lt;-</span> <span class="ide">JSON</span> <span class="op">*</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">JSON</span>           <span class="op">&lt;-</span> <span class="op">?</span><span class="ide">S</span> <span class="op">*</span> ( <span class="ide">jnumber</span> <span class="op">|</span> <span class="ide">jobject</span> <span class="op">|</span> <span class="ide">jarray</span> <span class="op">|</span> <span class="ide">jstring</span> <span class="op">|</span> <span class="ide">jtrue</span> <span class="op">|</span> <span class="ide">jfalse</span> <span class="op">|</span> <span class="ide">jnull</span> ) <span class="op">*</span> <span class="op">?</span><span class="ide">S</span></div></div><div class="line"><div class="line-content">  <span class="ide">jobject</span>        <span class="op">&lt;-</span> '{' <span class="op">*</span> ( <span class="ide">jstring</span> <span class="op">*</span> <span class="str">&quot;:&quot;</span> <span class="op">*</span> <span class="ide">JSON</span> <span class="op">*</span> <span class="op">*</span>( <span class="str">&quot;,&quot;</span> <span class="op">*</span> <span class="ide">jstring</span> <span class="op">*</span> <span class="str">&quot;:&quot;</span> <span class="op">*</span> <span class="ide">JSON</span> ) <span class="op">|</span> <span class="op">?</span><span class="ide">S</span> ) <span class="op">*</span> <span class="str">&quot;}&quot;</span></div></div><div class="line"><div class="line-content">  <span class="ide">jarray</span>         <span class="op">&lt;-</span> <span class="str">&quot;[&quot;</span> <span class="op">*</span> ( <span class="ide">JSON</span> <span class="op">*</span> <span class="op">*</span>( <span class="str">&quot;,&quot;</span> <span class="op">*</span> <span class="ide">JSON</span> ) <span class="op">|</span> <span class="op">?</span><span class="ide">S</span> ) <span class="op">*</span> <span class="str">&quot;]&quot;</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="ide">doAssert</span> <span class="ide">s</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">json</span>)<span class="op">.</span><span class="ide">ok</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">doc</span> <span class="op">=</span> """ {"jsonrpc": "2.0", "method": "subtract", "params": [42, 23], "id": 1} """</div></div><div class="line"><div class="line-content"><span class="ide">doAssert</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">doc</span>)<span class="op">.</span><span class="ide">ok</span></div></div>  </code></pre>
<h3>Captures</h3>
<p>The following example shows how to use code block captures. The defined
grammar will parse a HTTP response document and extract structured data from
the document into a Nim object:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content"><span class="kwd">import</span> <span class="ide">npeg</span>, <span class="ide">strutils</span>, <span class="ide">tables</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">type</span></div></div><div class="line"><div class="line-content">  <span class="ide">Request</span> <span class="op">=</span> <span class="kwd">object</span></div></div><div class="line"><div class="line-content">    <span class="ide">proto</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content">    <span class="ide">version</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content">    <span class="ide">code</span>: <span class="ide">int</span></div></div><div class="line"><div class="line-content">    <span class="ide">message</span>: <span class="ide">string</span></div></div><div class="line"><div class="line-content">    <span class="ide">headers</span>: <span class="ide">Table</span>[<span class="ide">string</span>, <span class="ide">string</span>]</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="com"># HTTP grammar (simplified)</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">parser</span> <span class="op">=</span> <span class="ide">peg</span>(<span class="str">&quot;http&quot;</span>, <span class="ide">userdata</span>: <span class="ide">Request</span>):</div></div><div class="line"><div class="line-content">  <span class="ide">space</span>       <span class="op">&lt;-</span> ' '</div></div><div class="line"><div class="line-content">  <span class="ide">crlf</span>        <span class="op">&lt;-</span> '\n' <span class="op">*</span> <span class="op">?</span>'\r'</div></div><div class="line"><div class="line-content">  <span class="ide">url</span>         <span class="op">&lt;-</span> <span class="op">+</span>(<span class="ide">Alpha</span> <span class="op">|</span> <span class="ide">Digit</span> <span class="op">|</span> '/' <span class="op">|</span> '_' <span class="op">|</span> '.')</div></div><div class="line"><div class="line-content">  <span class="ide">eof</span>         <span class="op">&lt;-</span> <span class="op">!</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">header_name</span> <span class="op">&lt;-</span> <span class="op">+</span>(<span class="ide">Alpha</span> <span class="op">|</span> '-')</div></div><div class="line"><div class="line-content">  <span class="ide">header_val</span>  <span class="op">&lt;-</span> <span class="op">+</span>(<span class="num">1</span><span class="op">-</span>{'\n'}<span class="op">-</span>{'\r'})</div></div><div class="line"><div class="line-content">  <span class="ide">proto</span>       <span class="op">&lt;-</span> <span class="op">&gt;+</span><span class="ide">Alpha</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">userdata</span><span class="op">.</span><span class="ide">proto</span> <span class="op">=</span> <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">version</span>     <span class="op">&lt;-</span> <span class="op">&gt;</span>(<span class="op">+</span><span class="ide">Digit</span> <span class="op">*</span> '.' <span class="op">*</span> <span class="op">+</span><span class="ide">Digit</span>):</div></div><div class="line"><div class="line-content">    <span class="ide">userdata</span><span class="op">.</span><span class="ide">version</span> <span class="op">=</span> <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">code</span>        <span class="op">&lt;-</span> <span class="op">&gt;+</span><span class="ide">Digit</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">userdata</span><span class="op">.</span><span class="ide">code</span> <span class="op">=</span> <span class="ide">parseInt</span>(<span class="op">$</span><span class="num">1</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">msg</span>         <span class="op">&lt;-</span> <span class="op">&gt;</span>(<span class="op">+</span>(<span class="num">1</span> <span class="op">-</span> '\r' <span class="op">-</span> '\n')):</div></div><div class="line"><div class="line-content">    <span class="ide">userdata</span><span class="op">.</span><span class="ide">message</span> <span class="op">=</span> <span class="op">$</span><span class="num">1</span></div></div><div class="line"><div class="line-content">  <span class="ide">header</span>      <span class="op">&lt;-</span> <span class="op">&gt;</span><span class="ide">header_name</span> <span class="op">*</span> <span class="str">&quot;: &quot;</span> <span class="op">*</span> <span class="op">&gt;</span><span class="ide">header_val</span>:</div></div><div class="line"><div class="line-content">    <span class="ide">userdata</span><span class="op">.</span><span class="ide">headers</span>[<span class="op">$</span><span class="num">1</span>] <span class="op">=</span> <span class="op">$</span><span class="num">2</span></div></div><div class="line"><div class="line-content">  <span class="ide">response</span>    <span class="op">&lt;-</span> <span class="ide">proto</span> <span class="op">*</span> '/' <span class="op">*</span> <span class="ide">version</span> <span class="op">*</span> <span class="ide">space</span> <span class="op">*</span> <span class="ide">code</span> <span class="op">*</span> <span class="ide">space</span> <span class="op">*</span> <span class="ide">msg</span></div></div><div class="line"><div class="line-content">  <span class="ide">headers</span>     <span class="op">&lt;-</span> <span class="op">*</span>(<span class="ide">header</span> <span class="op">*</span> <span class="ide">crlf</span>)</div></div><div class="line"><div class="line-content">  <span class="ide">http</span>        <span class="op">&lt;-</span> <span class="ide">response</span> <span class="op">*</span> <span class="ide">crlf</span> <span class="op">*</span> <span class="ide">headers</span> <span class="op">*</span> <span class="ide">eof</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="com"># Parse the data and print the resulting table</span></div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">const</span> <span class="ide">data</span> <span class="op">=</span> """
HTTP/1.1 301 Moved Permanently
Content-Length: 162
Content-Type: text/html
Location: https://nim.org/
"""</div></div><div class="line"><div class="line-content"></div></div><div class="line"><div class="line-content"><span class="kwd">var</span> <span class="ide">request</span>: <span class="ide">Request</span></div></div><div class="line"><div class="line-content"><span class="kwd">let</span> <span class="ide">res</span> <span class="op">=</span> <span class="ide">parser</span><span class="op">.</span><span class="ide">match</span>(<span class="ide">data</span>, <span class="ide">request</span>)</div></div><div class="line"><div class="line-content"><span class="ide">echo</span> <span class="ide">request</span></div></div>  </code></pre>
<p>The resulting data:</p>
<pre>  <code class="language-nim"><div class="line"><div class="line-content">(</div></div><div class="line"><div class="line-content">  <span class="ide">proto</span>: <span class="str">&quot;HTTP&quot;</span>,</div></div><div class="line"><div class="line-content">  <span class="ide">version</span>: <span class="str">&quot;1.1&quot;</span>,</div></div><div class="line"><div class="line-content">  <span class="ide">code</span>: <span class="num">301</span>,</div></div><div class="line"><div class="line-content">  <span class="ide">message</span>: <span class="str">&quot;Moved Permanently&quot;</span>,</div></div><div class="line"><div class="line-content">  <span class="ide">headers</span>: {</div></div><div class="line"><div class="line-content">    <span class="str">&quot;Content-Length&quot;</span>: <span class="str">&quot;162&quot;</span>,</div></div><div class="line"><div class="line-content">    <span class="str">&quot;Content-Type&quot;</span>:</div></div><div class="line"><div class="line-content">    <span class="str">&quot;text/html&quot;</span>,</div></div><div class="line"><div class="line-content">    <span class="str">&quot;Location&quot;</span>: <span class="str">&quot;https://nim.org/&quot;</span></div></div><div class="line"><div class="line-content">  }</div></div><div class="line"><div class="line-content">)</div></div>  </code></pre>
<h3>More examples</h3>
<p>More examples can be found in tests/examples.nim.</p>
<h2>Future directions / Todos / Roadmap / The long run</h2>
<p>Here are some things I&apos;d like to have implemented one day. Some are hard and
require me to better understand what I&apos;m doing first. In no particular order:</p>
<ul>
<li>
<p>Handling left recursion: PEGs are typically not good at handling grammar
invoking left recursion, see
https://en.wikipedia.org/wiki/Parsing_expression_grammar#Indirect_left_recursion
for an explanation of the problem. However, some smart people have found a way
to make this work anyway, but I am not yet able to understand this well enough
to implement this in NPeg.
https://github.com/zevv/npeg/blob/master/doc/papers/Left_recursion_in_parsing_expression_grammars.pdf</p>
</li>
<li>
<p>Design and implement a proper API for code block captures. The current API
feels fragile and fragmented (<code>capture[], $1/$2, fail(), validate()</code>), and
does not offer solid primitives to make custom match functions yet, something
better should be in place before NPeg goes v1.0.</p>
</li>
<li>
<p>Resuming/streaming: The current parser is almost ready to be invoked multiple
times, resuming parsing where it left off - this should allow parsing of
(infinite) streams. The only problem not solved yet is how to handle
captures: when a block of data is parsed it might contain data which must
later be available to collect the capture. Not sure how to handle this yet.</p>
</li>
<li>
<p>Memoization: I guess it would be possible to add (limited) memoization to
improve performance, but no clue where to start yet.</p>
</li>
<li>
<p>Parallelization: I wonder if parsing can parallelized: when reaching an
ordered choice, multiple threads should be able to try to parse each
individual choice. I do see problems with captures here, though.</p>
</li>
<li>
<p>I&apos;m not happy about the <code>{.gcsafe.}</code> workaround. I&apos;d be happy to hear any
ideas on how to improve this.</p>
</li>
</ul>
</document>
            
        </div>
        <div class="col-3" id="meta-section">
            <div class="container box rounded p-3">
                
                    <p>
                        <strong>Licence:</strong>
                        MIT
                    </p>
                

                
                    <p> <a href="https://github.com/zevv/npeg">Project website</a> </p>
                

                
            </div>
        </div>
    </div>
</div>
</div>

<footer class="pt-10 px-3">
  <div class="container pt-4">
    <div class="row mb-4">
      <div class="col-lg-3">
        <h4 class="h5">Getting started with Nim</h4>
        <ul>
          <li><a class="text-decoration-none" href="https://learnxinyminutes.com/docs/nim/">Learn Nim in 5 minutes</a></li>
          <li><a class="text-decoration-none" href="https://nim-by-example.github.io/">Nim by Example</a></li>
          <li><a class="text-decoration-none" href="https://play.nim-lang.org/">Official Playground</a></li>
        </ul>
      </div>
      <div class="col-lg-3">
        <h4 class="h5">Official Tutorials</h4>
        <ul>
          <li><a class="text-decoration-none" href="https://nim-lang.org/docs/tut1.html">General Tutorial</a></li>
          <li><a class="text-decoration-none" href="https://nim-lang.org/docs/tut2.html">Advanced Features</a></li>
          <li><a class="text-decoration-none" href="https://nim-lang.org/docs/tut3.html">Macros and Metaprogramming</a></li>
        </ul>
      </div>
      <div class="col-lg-3">
        <h4 class="h5">Nim for...</h4>
        <ul>
          <li><a class="text-decoration-none" href="https://github.com/nim-lang/Nim/wiki/Nim-for-C-programmers">C programmers</a></li>
          <li><a class="text-decoration-none" href="https://github.com/nim-lang/Nim/wiki/Nim-for-Python-Programmers">Python programmers</a></li>
          <li><a class="text-decoration-none" href="https://github.com/nim-lang/Nim/wiki/Nim-for-TypeScript-Programmers">TypeScript programmers</a></li>
        </ul>
      </div>
      <div class="col-lg-3">
        <h4 class="h5">Documentation</h4>
        <ul>
          <li><a class="text-decoration-none" href="https://nim-lang.org/docs/lib.html">Standard Library</a></li>
          <li><a class="text-decoration-none" href="https://nim-lang.org/docs/manual.html">Language Manual</a></li>
          <li><a class="text-decoration-none" href="https://nim-lang.org/docs/tools.html">Tools Documentation</a></li>
        </ul>
      </div>
    </div>
    <div class="row mt-3">
      <div class="col-12 text-center mt-4 mx-auto">
        <a href="#" class="d-block mb-3 mx-auto bw"></a>
        <p class="text-muted">
        Created in <a href="https://nim-lang.org/">Nim</a> on <a href="https://pages.github.com/">GitHub Pages</a>.
        <a href="https://github.com/gabbhack/nimidirectory">Available</a>
        under <a href="https://en.wikipedia.org/wiki/GNU_General_Public_License#Version_3">GPLv3</a>
        </p>
        <p class="text-muted">
        Builded at 2023-11-06T01:11:22Z
        </p>
      </div>
    </div>
  </div>
</footer>
<script>
</script>
</body>
</html>
